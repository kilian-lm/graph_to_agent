import json
import logging
import os
import inspect

from logger.CustomLogger import CustomLogger
# Initialize the custom logger
logger = CustomLogger(log_file='graph_processing.log').logger


class ContextManager:
    def __init__(self):
        self.responses = {}

    def add_response(self, label, response):
        self.responses[label] = response

    def get_response(self, label):
        return self.responses.get(label, '')

def get_node_type(node):
    # Adjust this logic to correctly determine the node type
    node_type = node['label'].split()[0].lower()
    logger.debug(f"Node ID: {node['id']}, Node Type: {node_type}")
    return node_type

def is_valid_sequence(component):
    expected_sequence = ['user', 'content', 'system', 'content', 'user', 'content']
    actual_sequence = [get_node_type(node) for node in component]
    logger.debug(f"Expected: {expected_sequence}")
    logger.debug(f"Actual: {actual_sequence}")
    return actual_sequence == expected_sequence

def process_component(component, context_manager):
    if not is_valid_sequence(component):
        logger.error("Component does not follow the required sequence")
        raise ValueError("Component does not follow the required sequence")

    processed_data = {"messages": []}
    for node in component:
        label = node["label"]
        if label.startswith('@'):
            variable_label = label[1:]
            label = context_manager.get_response(variable_label)

        processed_data["messages"].append({"content": label if get_node_type(node) != 'content' else "GPT response for: " + label})
    return processed_data

def identify_and_process_components(graph_data, context_manager):
    nodes, edges = graph_data["nodes"], graph_data["edges"]
    components = identify_graph_components(nodes, edges)
    logger.info(f"Identified {len(components)} components")
    return [process_component(component, context_manager) for component in components]


def identify_graph_components(nodes, edges):
    visited = set()
    components = []

    def dfs(node, component):
        visited.add(node['id'])
        component.append(node)
        for edge in edges:
            if edge['from'] == node['id'] and edge['to'] not in visited:
                to_node = next((n for n in nodes if n['id'] == edge['to']), None)
                if to_node:
                    dfs(to_node, component)

    for node in nodes:
        if node['id'] not in visited:
            component = []
            dfs(node, component)
            components.append(component)

    return components

context_manager = ContextManager()


graph_data = """
{
  "nodes": [
    {
      "id": "c7d1c0a4-6365-44d6-be0c-bd3fc5436b85",
      "label": "user"
    },
    {
      "id": "757e7439-08f8-4cea-afac-c25b01167d32",
      "label": "user"
    },
    {
      "id": "2e419e7e-a540-4c9a-af4e-5110e54fad96",
      "label": "system"
    },
    {
      "id": "07537a68-1c7e-4edb-a72f-2d82015c490f",
      "label": "Understood! As I'm an expert in the .puml syntax i will correct it"
    },
    {
      "id": "1cc45118-72ee-4efe-95d8-06e8c02fb4c0",
      "label": "The following is a .puml content generated by an agent. Please critically review it and correct any mistakes, especially ensuring it strictly adheres to .puml syntax and does not contain any elements from other diagramming languages like Mermaid"
    },
    {
      "id": "2d545024-3765-4b01-b1df-04da99ea4e80",
      "x": -575.9889498552049,
      "y": -331.9214349905721,
      "label": "sequenceDiagramAlice->>John: Hello John, how are you?John-->>Alice: Great!Alice-)John: See you later!"
    },
    {
      "id": "6f2c004b-b1e2-463b-964e-ab53cdf63d7a",
      "x": -1065.8683757853405,
      "y": 45.175328912081966,
      "label": "@variable"
    }
  ],
  "edges": [
    {
      "from": "07537a68-1c7e-4edb-a72f-2d82015c490f",
      "to": "757e7439-08f8-4cea-afac-c25b01167d32",
      "id": "84f178f5-9dba-4f5c-b525-e16ea173be2f"
    },
    {
      "from": "1cc45118-72ee-4efe-95d8-06e8c02fb4c0",
      "to": "2e419e7e-a540-4c9a-af4e-5110e54fad96",
      "id": "d535cac8-7bec-452e-b3ef-4c0184610ba3"
    },
    {
      "from": "2e419e7e-a540-4c9a-af4e-5110e54fad96",
      "to": "07537a68-1c7e-4edb-a72f-2d82015c490f",
      "id": "1764a3dc-3198-4e08-819e-51ccf56f4a07"
    },
    {
      "from": "c7d1c0a4-6365-44d6-be0c-bd3fc5436b85",
      "to": "1cc45118-72ee-4efe-95d8-06e8c02fb4c0",
      "id": "10bad7e6-bf61-42f2-95aa-47ba7abe6b30"
    }
  ]
}
"""

graph_data = json.loads(graph_data)

processed_components = identify_and_process_components(graph_data, context_manager)


# Simulating the GPT response
def simulate_gpt_response(processed_data):
    for data in processed_data:
        for message in data["messages"]:
            context_manager.add_response(message["content"], "GPT response for: " + message["content"])


simulate_gpt_response(processed_components)

# Output the processed components and context
processed_components, context_manager.responses
